using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace splitting
{
	static class SplitCounterStatic//Статический класс SplitCounterStatic
	{
		static public int[,] GetTable(int n)//Объявление метода GetTable, метод принимает аргументом целочисленный параметр n, отвечающий за размер таблицы
		{
			int[,] data = new int[n+1, n+1]; //Инициализция двумерного целочисленного массива data, в нем будет храниться таблица 
			for (int i = 0; i <= n; i++)//Массив заполняется нулями
			{
				for (int j = 0; j <= n; j++)
				{
					data[i, j] = 0;
				}
			}
			data[0, 0] = 1;//Для корректного заполнения массива элементу с индексами 0,0 на время присваеваем значение 1
			for (int i = 1; i <= n; i++)//Реализуем вышеописанный алгоритм
			{
				for (int j = 1; j <= i; j++)
				{
					for (int k = 0; k <= j; k++)
					{
						data[i, j] += data[i - j, k];//По сути весь массив заполняется по схеме из примера P(8,3)=P(5,0)+P(5,1)+P(5,2)+P(5,3).
					}
				}
			}
			data[0, 0] = 0; //Возвращаем верное значение элементу с индексами 0,0, ведь не существует разбиения числа 0 на 0 элементов.  


			return data; // Метод возвращает сгенерированный массив
		}
		static public decimal GetCount(int n) //Объявление метода GetCount, метод принимает аргументом целочисленный параметр n, отвечающий за число для которого будет рассчитано количество разбиений
		{
			int[,] data = GetTable(n);//Инициализация массива с помощью GetTable

			decimal count = data[n,1];//Переменную в которой будет храниться количество разбиений инициализируем первым значащим элементом заданной строки 
			for (int i = 2; i <= n; i++)//Начиная со второго значащего элемента и до конца строки к переменной count прибавляется значение следущего элемента строки  
			{
				count += data[n, i];
			}

			return count;//Метод возвращает посчитанное количество разбиений 
		}
		
	}
}
