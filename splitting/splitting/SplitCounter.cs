using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace splitting
{
	class SplitCounter
	{
		public int[,] data { get; private set; } //Поле data инкапсулирует двумерный целочисленный массив, представляющий таблицу количества разбиений
		public int MaxValue { get; private set; } //Поле MaxValue инкапсулирует размер таблицы, приватный setter позволяет избежать непредвиденного изменения этого значения 
		public SplitCounter(int maxValue)//Конструктор класса повторяет логику метода GetTable
		{
			MaxValue = maxValue;
			data = new int[MaxValue + 1, MaxValue + 1]; //Инициализция двумерного целочисленного массива data, в нем будет храниться таблица 
			for (int i = 0; i <= MaxValue; i++)//Массив заполняется нулями
			{
				for (int j = 0; j <= MaxValue; j++)
				{
					data[i, j] = 0;
				}
			}
			data[0, 0] = 1;//Для корректного заполнения массива элементу с индексами 0,0 на время присваеваем значение 1
			for (int i = 1; i <= MaxValue; i++)//Реализуем вышеописанный алгоритм
			{
				for (int j = 1; j <= i; j++)
				{
					for (int k = 0; k <= j; k++)
					{
						data[i, j] += data[i - j, k];//По сути весь массив заполняется по схеме из примера P(8,3)=P(5,0)+P(5,1)+P(5,2)+P(5,3).
					}
				}
			}
			data[0, 0] = 0; //Возвращаем верное значение элементу с индексами 0,0, ведь не существует разбиения числа 0 на 0 элементов.  
		}

		public int GetCount(int N)//Метод отличается от первой версии только тем, что он обращается к уже заполненной таблице и проверят аргумент чтоб он не выходил за границы массива
		{
			if (N <= MaxValue)
			{
				int count = data[N, 1];//Переменную в которой будет храниться количество разбиений инициализируем первым значащим элементом заданной строки 
				for (int i = 2; i <= N; i++)//Начиная со второго значащего элемента и до конца строки к переменной count прибавляется значение следущего элемента строки  
				{
					count += data[N, i];
				}

				return count;//Метод возвращает посчитанное количество разбиений 
			}
			else
				return -1;
		}
	}
}
